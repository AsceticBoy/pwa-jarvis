# Question Records

## 从传统的HTTPS演变到Web-Push加解密过程的记录

- `TLS/SSL加密协议`
  
  - 一般来说有两种加密方式：`AES为代表对称加密`、`RSA为代表的非对称加密`
  - 对称加密使用同一个秘钥，速度快，相对不安全
  - 非对称加密使用一对公私秘钥用来相互加解密，速度慢，但是相对安全

- `TCP握手过程(该过程为明文)`
  - 客户端 -> 服务端：1. 支持的 `TLS` 版本 2. 当前使用 `RSA` 加密 3. 产生一个随机数(用来后面生成 `session key` 的)
  - 服务器 -> 客户端：1. 是否支持 `TLS` 版本(不支持停止加密通信) 2. 返回服务证书(包含 `RSA` 公钥) 3. 产生一个随机数(用来后面生成 `session key` 的)
  - 客户端 -> 服务端：1. 生成第三个随机数(该随机数是用公钥加密传输的) 2. 后期的通信将利用 `session key` 进行对称加密通信的通知 3. 客户端握手结束，发送之前所有内容的 `hash` 供服务端校验
  - 服务器 -> 客户端：1. 根据三个随机数生成 `session key` 2. 通知加密方式变更，后续将利用 `session key` 进行对称加密 3. 服务端握手结束，发送之前所有内容的 `hash` 供客户端校验

- `TCP握手过程(⚠️ 注意事项)`
  - 注意1: 之所以需要三个随机数是为了防止第三方在窃听整个握手过程中，得到了两个明文随机数，需要靠第三个被公钥加密的随机数来大大降低被破译的可能，当然了从概率的角度来讲也是可以被破译的，所以有了 `DH非对称加密` ( 第三个随机数不需要传递，双方只要交换各自的参数，就可以算出这个随机数)
  - 注意2: 整个过程中其实只有在握手过程中涉及到了公私钥的加解密，通信过程中使用约定的 `session key` 进行对称加密通信

- `CA证书链`
  - 假设在一种情况：在服务端告诉客户端公钥的过程中，劫持方用自己的公钥私自替换了真正的公钥(那他有极大的可能用自己的私钥破译第三个随机数)，如何避免
  - 这时就需要公证机构的 `CA机构的证书` 来做担保，简单来说就是：1. `登记`：服务端先用认证机构放出来的公钥加密自己的信息(内含自己的公钥)发给认证机构 2. `盖戳`：认证机构用私钥解密后发现信息没有问题后(相关数据 `hash` 处理)发放数字证书 3. `验证`：携带数字证书的服务端公钥到客户端手里后，利用机构公钥进行验证(相关数据 `hash` 处理后和证书 `hash` 做对比)，确认无误后走下面的流程(即服务端公钥没有问题)...